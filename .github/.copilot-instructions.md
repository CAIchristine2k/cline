# Shopify Hydrogen Template 

## Project Overview
This is a Shopify Hydrogen template, which is a React-based framework for building custom storefronts with Shopify. The project uses TypeScript, React, and GraphQL to interact with Shopify's Storefront API and Customer Account API.

This template is specifically designed as a highly customizable influencer store template that can be adapted for different influencers through a central configuration system without code changes.

# CRITICAL DEVELOPMENT PRINCIPLES - ALWAYS FOLLOW

## DRY (Don't Repeat Yourself) and Single Source of Truth

These principles are MANDATORY for all development in this codebase:

1. **Configuration Single Source of Truth**: 
   - ALL configuration MUST be defined in `app/utils/config.ts`
   - NEVER duplicate configuration values across components
   - ALWAYS access configuration via the `useConfig()` hook

2. **Theme Single Source of Truth**:
   - ALL theme styling MUST be derived from the theme system in `app/utils/themeConfig.ts`
   - NEVER create separate style utility files that might get out of sync
   - NEVER hardcode colors, sizes, or other theme values in components
   - ALWAYS use CSS variables generated from the theme system

3. **Component Implementation**:
   - ALWAYS use the `useConfig()` hook from `~/utils/themeContext` to access configuration
   - ALWAYS use Tailwind classes that reference CSS variables for styling
   - NEVER create component-specific style utilities that duplicate theme logic
   - NEVER use inline styles for values that should come from the theme
   - ALWAYS prefer CSS variables over hardcoded values

4. **CSS Approach**:
   - ALWAYS use `text-primary`, `bg-primary`, etc. which reference CSS variables
   - ALWAYS use `shadow-glow`, `animate-pulse`, etc. utility classes from the theme
   - NEVER create duplicate shadow, animation, or other style effects
   - ALWAYS implement component-specific styles through CSS variables

5. **Feature Flags**:
   - ALWAYS use configuration toggles (e.g., `showLimitedEdition`) to control feature visibility
   - NEVER implement redundant logic for showing/hiding features

6. **Media Assets**:
   - ALWAYS store image and video assets in the `/public` directory
   - Use relative paths (e.g., `/images/logo.svg`) in the configuration
   - For SVG assets, prefer inline SVG when the asset benefits from theme color variables
   - For background videos, ensure they have a fallback image defined in the config

Failing to follow these principles will result in:
- Theme inconsistency
- Broken customizability
- Difficulty maintaining the codebase
- Bugs when configuration changes

## Key Project Structure

### Main Directories
- `/app`: Main application code
  - `/components`: React components for the storefront
  - `/graphql`: GraphQL queries and schema references
    - `/customer-account`: Customer API query files
    - `/graphql-schema`: Complete API schema reference files (for developer reference)
  - `/routes`: Route files using Remix-style file conventions
  - `/lib`: Utility libraries
  - `/styles`: CSS styles
  - `/utils`: Utility functions and configuration
    - `config.ts`: Central configuration file for the entire application
    - `themeConfig.ts`: Theme styling configuration and CSS variable generation
    - `themeContext.tsx`: React context for providing theme and config throughout the app
  - `/providers`: React context providers
    - `CartProvider.tsx`: Manages cart state and functionality
- `/public`: Static assets
  - `/images`: Image assets for the site (logo, product images, etc.)
  - `/videos`: Video assets for hero backgrounds or product demonstrations
- `/guides`: Documentation

### Key Configuration Files
- `.graphqlrc.ts`: GraphQL configuration for code generation
- `storefrontapi.generated.d.ts`: Generated types for Storefront API (only used types)
- `customer-accountapi.generated.d.ts`: Generated types for Customer API (only used types)
- `vite.config.ts`: Vite configuration
- `tailwind.config.ts`: Tailwind CSS configuration

# Theme System and Configuration

## Single Source of Truth Approach

This template follows a strict "single source of truth" approach to configuration and styling:

1. All configuration is centralized in `app/utils/config.ts`
2. Theme styles are defined in `app/utils/themeConfig.ts` and controlled by the configuration
3. Theme context in `app/utils/themeContext.tsx` provides access to configuration throughout the app
4. CSS variables are generated from the theme configuration
5. Components use Tailwind CSS classes that leverage these CSS variables

## Configuration Files

### 1. `app/utils/config.ts`

This is the central configuration file for the entire application. It contains:

- Brand and influencer details (`influencerName`, `brandName`, etc.)
- Visual theme settings (`brandStyle`, `heroBackgroundImage`, etc.)
- Content text and CTAs (`heroTitle`, `ctaText`, etc.)
- Product information
- Social media links
- Section visibility toggles (`showLimitedEdition`, `showCareerHighlights`, etc.)
- Contact information
- Shopify configuration (`featuredProducts`, `featuredCollections`, etc.)

Example:
```typescript
export const defaultConfig: LandingPageConfig = {
  // Brand & Influencer Details
  influencerName: "Shane Mosley",
  influencerTitle: "Boxing Legend & 9-Time World Champion",
  brandName: "SUGAR SHANE",
  
  // Visual Theme
  brandStyle: "luxury", // Options: luxury, sporty, casual, technical, minimalist, vibrant, custom
  
  // Navigation
  navigation: [
    { name: "Home", href: "/" },
    { name: "Shop", href: "#shop" },
    // ...more navigation items
  ],
  
  // Features & Sections
  showLimitedEdition: true,
  showCareerHighlights: true,
  showTestimonials: true,
  showSocialFeed: true,
  
  // Shopify Configuration
  shopify: {
    featuredProducts: ["product-handle-1", "product-handle-2"],
    featuredCollections: [],
    mainCollectionHandle: "all",
    defaultSorting: "manual",
    productsPerPage: 12,
    enableCustomerAccounts: true,
  },
  
  // ... more configuration options
};
```

### 2. `app/utils/themeConfig.ts`

This file handles theme styling:

- Defines color schemes for different brand styles (`luxury`, `sporty`, `casual`, etc.)
- Generates CSS variables based on the selected theme
- Provides utility functions for adjusting colors and applying themes

The template includes predefined color schemes for different brand styles, but also supports custom theming.

### 3. `app/utils/themeContext.tsx`

This provides a React context for accessing the theme and configuration throughout the application:

- `useConfig()` - Hook to access configuration
- `useTheme()` - Hook to access theme settings
- `useUpdateConfig()` - Hook to update configuration

## DRY Principles and CSS Approach

The template follows these principles:

1. **No Hardcoded Styles**: All colors and styling are derived from the theme system
2. **CSS Variables**: All styling is managed through CSS variables that are updated when the theme changes
3. **Tailwind Integration**: Components use Tailwind classes that reference CSS variables
4. **No Style Duplication**: No separate style files or utility files that duplicate theme information

## Component Style Implementation

Components should be implemented following these guidelines:

1. Use `useConfig()` hook to access configuration
2. Use Tailwind classes for styling, especially utility classes like:
   - `bg-primary` (uses --color-primary CSS variable)
   - `text-primary` (uses --color-primary CSS variable)
   - `hover:bg-primary-600` (uses color variations)

Example of a properly styled component:

```tsx
import { useConfig } from '~/utils/themeContext';

export function ExampleComponent() {
  const config = useConfig();
  
  return (
    <div className="bg-black/40 backdrop-blur-sm border border-primary/30 p-4 rounded-sm">
      <h2 className="text-2xl font-bold text-white mb-4">
        {config.sectionTitle}
      </h2>
      <p className="text-gray-300">
        {config.sectionContent}
      </p>
      <button className="bg-primary hover:bg-primary-600 text-black font-bold py-2 px-4 rounded-sm mt-4">
        {config.buttonText}
      </button>
    </div>
  );
}
```

## Product Display Components

The template includes several components for displaying products:

1. **ProductCard.tsx**: Used in grids and product listings
2. **ProductItem.tsx**: Alternative product card used in specific contexts
3. **ProductShowcase.tsx**: Displays a grid of products with heading and CTA

These components follow a consistent design language and must:

1. Use the central theme system for styling
2. Display badges (Sale, New, Featured) based on product tags and configuration
3. Include consistent rating stars
4. Properly format prices and show sale prices when available
5. Include "Add to Cart" functionality using the AddToCartButton component

Example usage of ProductShowcase:

```tsx
import { ProductShowcase } from '~/components/ProductShowcase';

// In your component:
<ProductShowcase
  products={products}
  title="EXCLUSIVE MERCHANDISE"
  subtitle={`Premium quality products inspired by the legacy of ${config.influencerName}.`}
/>
```

## Cart Functionality

The cart system uses several key components:

1. **CartProvider.tsx**: Manages cart state and provides cart functionality
2. **CartMain.tsx**: Main cart component for displaying cart items
3. **CartLineItem.tsx**: Individual cart line items
4. **CartSummary.tsx**: Displays cart totals and checkout button
5. **AddToCartButton.tsx**: Button for adding items to cart
6. **Aside.tsx**: Slide-in panel for cart display

The cart provider integrates with the Aside component for displaying the cart drawer.
To add an item to the cart, use the AddToCartButton component:

```tsx
import { AddToCartButton } from '~/components/AddToCartButton';

// In your component:
<AddToCartButton 
  lines={[{merchandiseId: variantId, quantity: 1}]}
  className="bg-primary text-background py-2 px-4 rounded-sm"
>
  Add to Cart
</AddToCartButton>
```

## Image and Media Implementation

For proper image and video handling in the template:

1. **File Organization**:
   - Store all images in the `/public/images/` directory
   - Store all videos in the `/public/videos/` directory
   - Use SVG images for logos and icons when possible (allows theme color application)

2. **Config References**:
   - All image and video paths should be defined in the config file
   - Use absolute paths relative to the public directory (e.g., `/images/logo.svg`)
   - For hero sections with video, always provide an image fallback

3. **Video Handling**:
   - Add proper controls and accessibility for video elements
   - Implement playback optimizations (lazy loading, preload="metadata")
   - For autoplay videos, handle autoplay restrictions gracefully with fallbacks

4. **SVG Best Practices**:
   - For theme-sensitive SVGs, use currentColor for fill/stroke to inherit theme colors
   - For complex SVGs, use the img tag with SVG files from the public directory
   - For simple icons that change color with theme, consider inline SVG

Example component with proper image/video handling:

```tsx
import { useConfig } from '~/utils/themeContext';
import { useRef, useEffect } from 'react';

export function HeroSection() {
  const config = useConfig();
  const videoRef = useRef<HTMLVideoElement>(null);
  
  useEffect(() => {
    // Handle autoplay restrictions
    if (videoRef.current) {
      const playPromise = videoRef.current.play();
      if (playPromise !== undefined) {
        playPromise.catch(() => {
          // Video autoplay was prevented, fallback to poster image is shown
        });
      }
    }
  }, []);
  
  return (
    <div className="relative h-screen overflow-hidden">
      {config.heroVideoUrl ? (
        <video
          ref={videoRef}
          poster={config.heroBackgroundImage}
          className="absolute inset-0 w-full h-full object-cover"
          muted
          loop
          playsInline
          preload="metadata"
        >
          <source src={config.heroVideoUrl} type="video/mp4" />
          {/* Fallback to image if video fails */}
        </video>
      ) : (
        <img 
          src={config.heroBackgroundImage} 
          alt={config.heroTitle}
          className="absolute inset-0 w-full h-full object-cover"
        />
      )}
      
      <div className="relative z-10 container mx-auto px-4 h-full flex items-center">
        <div className="text-white max-w-2xl">
          <h1 className="text-4xl md:text-6xl font-bold mb-4">{config.heroTitle}</h1>
          <p className="text-xl mb-8">{config.heroSubtitle}</p>
          <button className="bg-primary hover:bg-primary-600 text-black font-bold py-3 px-8 rounded-sm">
            {config.heroCta}
          </button>
        </div>
      </div>
    </div>
  );
}
```

## Special CSS Classes

The template includes some special CSS classes for common styling needs:

- `shadow-glow`: Adds a glow effect using the primary color
- `animate-pulse`, `animate-fadeIn`, etc.: Animation utilities
- Custom text shadow classes (defined in component-specific styles)

## GraphQL Schema Generation

The project is configured to generate two sets of type definitions:

1. **Used Types Only**:
   - `storefrontapi.generated.d.ts`: Contains types from the Storefront API that are actually used in the application
   - `customer-accountapi.generated.d.ts`: Contains types from the Customer API that are actually used in the application

2. **Full Schema Reference**:
   - `graphql-schema/storefront-schema.generated.ts`: Complete schema types for Storefront API
   - `graphql-schema/customer-schema.generated.ts`: Complete schema types for Customer API

## How to Regenerate Schema Types

To regenerate both used type definitions and full schema references:

```bash
npm run codegen
# or
yarn codegen
```

This command triggers GraphQL code generation based on the configuration in `.graphqlrc.ts`.

## Important Developer Notes

1. When developing new features that interact with Shopify's APIs:
   - For implementation: Use the root-level generated type files (`storefrontapi.generated.d.ts` and `customer-accountapi.generated.d.ts`)
   - For reference/discovery of available API features: Consult the full schema files in `graphql-schema`

2. When adding new GraphQL queries:
   - For Storefront API: Add them to the appropriate component or route files
   - For Customer API: Add them to `/app/graphql/customer-account/` directory
   - Then run `npm run codegen` to update the type definitions

3. Don't manually edit the generated type files as they will be overwritten when codegen runs.

4. When working with components:
   - Always use the `useConfig()` hook from `~/utils/themeContext` to access configuration
   - Use Tailwind classes that reference CSS variables for styling
   - Avoid hardcoding any styles or colors that should come from the theme
   - Make components respond to configuration changes

## Routes Structure

The project uses a file-based routing system with Remix-style conventions:
- Routes with `($locale)` handle internationalization
- Routes with `._index` represent index pages
- Routes with `.$paramName` handle dynamic parameters
- Routes with `._` denote layout routes

## Key Components
- `PageLayout.tsx`: Main layout component
- `Header.tsx` and `Footer.tsx`: Site-wide navigation components
- `ProductCard.tsx`, `ProductDetail.tsx`: Product display components
- `ProductShowcase.tsx`: Product grid display for featured products
- `CartMain.tsx`, `CartSummary.tsx`: Shopping cart components
- `Hero.tsx`: Main landing page hero section
- `LimitedEdition.tsx`: Limited edition product section with countdown
- `Aside.tsx`: Slide-in panel for cart, search, and mobile menu

# React Router Import Rule for Hydrogen

## Overview

This Hydrogen project is based on React Router, not Remix. When working with documentation or code examples, you should always use imports from the appropriate React Router packages instead of Remix packages.

## Import Replacements

When you see imports from Remix packages, replace them with their equivalent React Router v7 packages. Here are the common replacements:

| Remix v2 Package | React Router v7 Package |
|------------------|-------------------------|
| `@remix-run/react` | `react-router` |
| `@remix-run/dev` | `@react-router/dev` |
| `@remix-run/architect` | `@react-router/architect` |
| `@remix-run/cloudflare` | `@react-router/cloudflare` |
| `@remix-run/express` | `@react-router/express` |
| `@remix-run/fs-routes` | `@react-router/fs-routes` |
| `@remix-run/node` | `@react-router/node` |
| `@remix-run/route-config` | `@react-router/dev` |
| `@remix-run/routes-option-adapter` | `@react-router/remix-routes-option-adapter` |
| `@remix-run/serve` | `@react-router/serve` |
| `@remix-run/server-runtime` | `react-router` |
| `@remix-run/testing` | `react-router` |

NEVER USE 'react-router-dom' imports!

## Common Import Examples

```js
// INCORRECT (Remix style)
import { useLoaderData, Link, Form, useActionData, useNavigation, useSubmit } from '@remix-run/react';

// CORRECT (React Router style)
import { useLoaderData, Link, Form, useActionData, useNavigation, useSubmit } from 'react-router';
```

## Development Guidelines

1. Always check existing code in the project to understand which specific React Router hooks and components are being used
2. When generating new code or modifying existing code, ensure all routing-related imports come from the correct React Router packages
3. If following documentation or examples based on Remix, adapt the code to use React Router equivalents

When working in this codebase, always follow the React Router patterns that are already established in the existing code.

For more information, consult the official Remix to React Router upgrade guide: https://reactrouter.com/upgrading/remix
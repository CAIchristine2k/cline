---
description: 
globs: 
alwaysApply: true
---
# Shopify Hydrogen Template 

## Project Overview
This is a Shopify Hydrogen template, which is a React-based framework for building custom storefronts with Shopify. The project uses TypeScript, React, and GraphQL to interact with Shopify's Storefront API and Customer Account API.

This template is specifically designed as a highly customizable influencer store template that can be adapted for different influencers through a central configuration system without code changes.

# HYDROGEN DOCUMENTATION REFERENCE

## Latest Documentation Location
The most up-to-date Hydrogen documentation, examples, and demos are located in:
**`./hydrogen-2025-05/`**

This directory contains:
- Latest component documentation and examples
- Updated API patterns and best practices
- Current Hydrogen hooks and utilities
- GraphQL schema references
- Cart functionality patterns
- Performance optimization guides

ALWAYS reference this directory for:
- Latest Hydrogen patterns and implementations
- Component usage examples
- API documentation
- Troubleshooting guides
- Best practice implementations

# CRITICAL DEVELOPMENT PRINCIPLES - ALWAYS FOLLOW

## DRY (Don't Repeat Yourself) and Single Source of Truth

These principles are MANDATORY for all development in this codebase:

1. **Configuration Single Source of Truth**: 
   - ALL configuration MUST be defined in `app/utils/config.ts`
   - NEVER duplicate configuration values across components
   - ALWAYS access configuration via the `useConfig()` hook

2. **Theme Single Source of Truth**:
   - ALL theme styling MUST be derived from the theme system in `app/utils/themeConfig.ts`
   - NEVER create separate style utility files that might get out of sync
   - NEVER hardcode colors, sizes, or other theme values in components
   - ALWAYS use CSS variables generated from the theme system

3. **Component Implementation**:
   - ALWAYS use the `useConfig()` hook from `~/utils/themeContext` to access configuration
   - ALWAYS use Tailwind classes that reference CSS variables for styling
   - NEVER create component-specific style utilities that duplicate theme logic
   - NEVER use inline styles for values that should come from the theme
   - ALWAYS prefer CSS variables over hardcoded values

4. **CSS Approach**:
   - ALWAYS use `text-primary`, `bg-primary`, etc. which reference CSS variables
   - ALWAYS use `shadow-glow`, `animate-pulse`, etc. utility classes from the theme
   - NEVER create duplicate shadow, animation, or other style effects
   - ALWAYS implement component-specific styles through CSS variables

5. **Feature Flags**:
   - ALWAYS use configuration toggles (e.g., `showLimitedEdition`) to control feature visibility
   - NEVER implement redundant logic for showing/hiding features

6. **Media Assets**:
   - ALWAYS store image and video assets in the `/public` directory
   - Use relative paths (e.g., `/images/logo.svg`) in the configuration
   - For SVG assets, prefer inline SVG when the asset benefits from theme color variables
   - For background videos, ensure they have a fallback image defined in the config

Failing to follow these principles will result in:
- Theme inconsistency
- Broken customizability
- Difficulty maintaining the codebase
- Bugs when configuration changes

## Key Project Structure

### Main Directories
- `/app`: Main application code
  - `/components`: React components for the storefront
  - `/graphql`: GraphQL queries and schema references
    - `/customer-account`: Customer API query files
    - `/graphql-schema`: Complete API schema reference files (for developer reference)
  - `/routes`: Route files using Remix-style file conventions
  - `/lib`: Utility libraries
  - `/styles`: CSS styles
  - `/utils`: Utility functions and configuration
    - `config.ts`: Central configuration file for the entire application
    - `themeConfig.ts`: Theme styling configuration and CSS variable generation
    - `themeContext.tsx`: React context for providing theme and config throughout the app
  - `/providers`: React context providers
    - `CartProvider.tsx`: Manages cart state and functionality
- `/public`: Static assets
  - `/images`: Image assets for the site (logo, product images, etc.)
  - `/videos`: Video assets for hero backgrounds or product demonstrations
- `/guides`: Documentation
- `/hydrogen-2025-05`: Latest Hydrogen documentation, examples, and demos

### Key Configuration Files
- `.graphqlrc.ts`: GraphQL configuration for code generation
- `storefrontapi.generated.d.ts`: Generated types for Storefront API (only used types)
- `customer-accountapi.generated.d.ts`: Generated types for Customer API (only used types)
- `vite.config.ts`: Vite configuration
- `tailwind.config.ts`: Tailwind CSS configuration

# Theme System and Configuration

## Single Source of Truth Approach

This template follows a strict "single source of truth" approach to configuration and styling:

1. All configuration is centralized in `app/utils/config.ts`
2. Theme styles are defined in `app/utils/themeConfig.ts` and controlled by the configuration
3. Theme context in `app/utils/themeContext.tsx` provides access to configuration throughout the app
4. CSS variables are generated from the theme configuration
5. Components use Tailwind CSS classes that leverage these CSS variables

## Configuration Files

### 1. `app/utils/config.ts`

This is the central configuration file for the entire application. It contains:

- Brand and influencer details (`influencerName`, `brandName`, etc.)
- Visual theme settings (`brandStyle`, `heroBackgroundImage`, etc.)
- Content text and CTAs (`heroTitle`, `ctaText`, etc.)
- Product information
- Social media links
- Section visibility toggles (`showLimitedEdition`, `showCareerHighlights`, etc.)
- Contact information
- Shopify configuration (`featuredProducts`, `featuredCollections`, etc.)

Example:
```typescript
export const defaultConfig: LandingPageConfig = {
  // Brand & Influencer Details
  influencerName: "Shane Mosley",
  influencerTitle: "Boxing Legend & 9-Time World Champion",
  brandName: "SUGAR SHANE",
  
  // Visual Theme
  brandStyle: "luxury", // Options: luxury, sporty, casual, technical, minimalist, vibrant, custom
  
  // Navigation
  navigation: [
    { name: "Home", href: "/" },
    { name: "Shop", href: "#shop" },
    // ...more navigation items
  ],
  
  // Features & Sections
  showLimitedEdition: true,
  showCareerHighlights: true,
  showTestimonials: true,
  showSocialFeed: true,
  
  // Shopify Configuration
  shopify: {
    featuredProducts: ["product-handle-1", "product-handle-2"],
    featuredCollections: [],
    mainCollectionHandle: "all",
    defaultSorting: "manual",
    productsPerPage: 12,
    enableCustomerAccounts: true,
  },
  
  // ... more configuration options
};
```

### 2. `app/utils/themeConfig.ts`

This file handles theme styling:

- Defines color schemes for different brand styles (`luxury`, `sporty`, `casual`, etc.)
- Generates CSS variables based on the selected theme
- Provides utility functions for adjusting colors and applying themes

The template includes predefined color schemes for different brand styles, but also supports custom theming.

### 3. `app/utils/themeContext.tsx`

This provides a React context for accessing the theme and configuration throughout the application:

- `useConfig()` - Hook to access configuration
- `useTheme()` - Hook to access theme settings
- `useUpdateConfig()` - Hook to update configuration

## DRY Principles and CSS Approach

The template follows these principles:

1. **No Hardcoded Styles**: All colors and styling are derived from the theme system
2. **CSS Variables**: All styling is managed through CSS variables that are updated when the theme changes
3. **Tailwind Integration**: Components use Tailwind classes that reference CSS variables
4. **No Style Duplication**: No separate style files or utility files that duplicate theme information

## Component Style Implementation

Components should be implemented following these guidelines:

1. Use `useConfig()` hook to access configuration
2. Use Tailwind classes for styling, especially utility classes like:
   - `bg-primary` (uses --color-primary CSS variable)
   - `text-primary` (uses --color-primary CSS variable)
   - `hover:bg-primary-600` (uses color variations)

Example of a properly styled component:

```tsx
import { useConfig } from '~/utils/themeContext';

export function ExampleComponent() {
  const config = useConfig();
  
  return (
    <div className="bg-black/40 backdrop-blur-sm border border-primary/30 p-4 rounded-sm">
      <h2 className="text-2xl font-bold text-white mb-4">
        {config.sectionTitle}
      </h2>
      <p className="text-gray-300">
        {config.sectionContent}
      </p>
      <button className="bg-primary hover:bg-primary-600 text-black font-bold py-2 px-4 rounded-sm mt-4">
        {config.buttonText}
      </button>
    </div>
  );
}
```

## Product Display Components

The template includes several components for displaying products:

1. **ProductCard.tsx**: Used in grids and product listings
2. **ProductItem.tsx**: Alternative product card used in specific contexts
3. **ProductShowcase.tsx**: Displays a grid of products with heading and CTA

These components follow a consistent design language and must:

1. Use the central theme system for styling
2. Display badges (Sale, New, Featured) based on product tags and configuration
3. Include consistent rating stars
4. Properly format prices and show sale prices when available
5. Include "Add to Cart" functionality using the AddToCartButton component

Example usage of ProductShowcase:

```tsx
import { ProductShowcase } from '~/components/ProductShowcase';

// In your component:
<ProductShowcase
  products={products}
  title="EXCLUSIVE MERCHANDISE"
  subtitle={`Premium quality products inspired by the legacy of ${config.influencerName}.`}
/>
```

# Cart Functionality - COMPREHENSIVE IMPLEMENTATION GUIDE

## Overview
The cart system in this Hydrogen template has been fully implemented and tested with both server-side and client-side components working together seamlessly. **All cart functionality is operational including add to cart, quantity updates, item removal, and optimistic updates.**

## Key Cart Components

1. **CartProvider.tsx**: Manages cart state and provides cart functionality
2. **CartMain.tsx**: Main cart component for displaying cart items with useOptimisticCart
3. **CartLineItem.tsx**: Individual cart line items with working +/- and remove buttons
4. **CartSummary.tsx**: Displays cart totals and checkout button
5. **AddToCartButton.tsx**: Button for adding items to cart (FULLY OPERATIONAL)
6. **Aside.tsx**: Slide-in panel for cart display

## Cart Route Structure - WORKING IMPLEMENTATION

The cart functionality uses two main routes that are both operational:
- `/cart` - Handles API operations with proper CartForm.getFormInput parsing
- `/($locale).cart.tsx` - Handles cart page display and fallback actions

Both routes use simplified, reliable form handling:

```tsx
export async function action({request, context}: ActionFunctionArgs) {
  const {cart} = context;
  const formData = await request.formData();
  
  const {action, inputs} = CartForm.getFormInput(formData);
  console.log('Parsed action:', action, 'inputs:', inputs);

  switch (action) {
    case CartForm.ACTIONS.LinesAdd:
      result = await cart.addLines(inputs.lines);
      break;
    case CartForm.ACTIONS.LinesUpdate:
      result = await cart.updateLines(inputs.lines);
      break;
    case CartForm.ACTIONS.LinesRemove:
      result = await cart.removeLines(inputs.lineIds);
      break;
    // ... other actions
  }
  
  return data({cart: result.cart, errors: result.errors});
}
```

## AddToCartButton Implementation - FULLY WORKING

The AddToCartButton component has been fixed and is fully operational:

### Key Features:
- Uses flexible `SelectedVariant` type that matches actual GraphQL data
- Properly implements CartForm with correct action routing
- Provides optimistic cart functionality
- Opens cart drawer after successful addition
- Shows proper loading states

### Correct Type Definition:
```tsx
// Flexible type for selectedVariant that matches our actual GraphQL data
type SelectedVariant = {
  id: string;
  availableForSale?: boolean;
  title?: string;
  price?: {
    amount: string;
    currencyCode: string;
  };
  compareAtPrice?: {
    amount: string;
    currencyCode: string;
  } | null;
  selectedOptions?: Array<{
    name: string;
    value: string;
  }>;
  [key: string]: any; // Allow additional fields
};
```

### Usage Pattern:
```tsx
<AddToCartButton
  lines={[{merchandiseId: variantId, quantity: 1}]}
  selectedVariant={firstVariant} // CRITICAL: Required for optimistic updates
  className="bg-primary text-background py-2 px-4 rounded-sm"
>
  Add to Cart
</AddToCartButton>
```

## CartLineItem Implementation - FULLY WORKING

The CartLineItem component has working quantity adjustment and removal:

### Quantity Controls:
```tsx
<CartForm
  route="/cart"
  action={CartForm.ACTIONS.LinesUpdate}
  inputs={{lines: [{id: lineId, quantity: newQuantity}]}}
>
  <button type="submit" aria-label="Increase/Decrease quantity">
    <Plus/Minus className="w-4 h-4" />
  </button>
</CartForm>
```

### Remove Button:
```tsx
<CartForm
  route="/cart"
  action={CartForm.ACTIONS.LinesRemove}
  inputs={{lineIds: [lineId]}}
>
  <button type="submit" aria-label="Remove from cart">
    <Trash2 className="h-4 w-4 text-red-500" />
  </button>
</CartForm>
```

## Optimistic Cart Updates - OPERATIONAL

The cart system now provides immediate UI feedback:
- Uses `useOptimisticCart` hook in CartMain component
- All cart operations update UI immediately
- Proper handling of optimistic line items with `isOptimistic` flag
- Buttons disabled appropriately during optimistic states

## Testing Infrastructure - COMPREHENSIVE

### Test Pages Available:
1. **Main Store**: `http://localhost:3000` - Real product testing
2. **Cart Test Page**: `http://localhost:3000/shopify-test` - Comprehensive testing interface
3. **Cart Page**: `http://localhost:3000/cart` - Direct cart functionality testing

### Debug Logging:
Comprehensive console logging for troubleshooting:
```
======= CART ACTION DEBUG =======
Raw formData entries: { action: 'LinesAdd', ... }
Parsed action: LinesAdd inputs: { lines: [...] }
Cart addLines result: { cart: {...}, userErrors: [] }
Final cart result: { cartId: 'gid://...', totalQuantity: 2 }
======= END DEBUG =======
```

## Resolved Issues - FIXED

### 1. TypeScript Type Conflicts ✅
- **Issue**: `ProductVariant` type was too restrictive and didn't match GraphQL data
- **Solution**: Created flexible `SelectedVariant` type that accommodates actual data structure
- **Result**: No TypeScript compilation errors

### 2. Cart Button Functionality ✅
- **Issue**: Cart buttons not responding to clicks
- **Solution**: Proper CartForm implementation with correct action and inputs
- **Result**: All cart operations working (add, update, remove)

### 3. Optimistic Updates ✅
- **Issue**: Cart state not updating immediately
- **Solution**: Pass selectedVariant to AddToCartButton and use useOptimisticCart
- **Result**: Immediate UI feedback for all cart operations

### 4. Form Data Parsing ✅
- **Issue**: Complex manual parsing causing failures
- **Solution**: Use CartForm.getFormInput for reliable parsing
- **Result**: Consistent cart action handling

## Best Practices - VERIFIED WORKING

1. **Always pass selectedVariant**: Required for optimistic cart updates
2. **Use CartForm for all operations**: Reliable form handling and parsing
3. **Proper type definitions**: Flexible types that match actual GraphQL data
4. **Comprehensive testing**: Use test page for verifying functionality
5. **Debug logging**: Detailed console logs for troubleshooting

## Performance Optimizations - IMPLEMENTED

- Optimistic updates provide immediate feedback
- Cart state cached and persists across navigation
- Minimal re-renders through proper state management
- Efficient GraphQL queries for cart data
- Proper loading states without blocking UI

## Cart Provider Integration - WORKING

The cart provider properly integrates with the Aside component:

```tsx
const {openCart} = useCart();

// Open cart after successful addition
setTimeout(() => {
  openCart();
}, 300);
```

## Example Complete Working Implementation

```tsx
import { AddToCartButton } from '~/components/AddToCartButton';

// In your product component - THIS WORKS:
<AddToCartButton 
  lines={[{
    merchandiseId: formatVariantId(variantId),
    quantity: 1
  }]}
  selectedVariant={firstVariant} // CRITICAL: Always include this
  className="bg-primary hover:bg-primary-600 text-background py-2 px-4 rounded-sm"
>
  <ShoppingCart className="w-4 h-4" />
</AddToCartButton>
```

## Cart Functionality Status: 100% OPERATIONAL ✅

All cart functionality has been implemented, tested, and verified working:
- ✅ Add items to cart with immediate UI feedback
- ✅ Update quantities with +/- buttons
- ✅ Remove items with trash icon
- ✅ Cart persistence across navigation and refresh
- ✅ Optimistic updates for smooth UX
- ✅ Mobile responsive cart functionality
- ✅ Proper error handling and debug logging
- ✅ TypeScript type safety

The cart system is production-ready and follows all Hydrogen best practices.

## Image and Media Implementation

For proper image and video handling in the template:

1. **File Organization**:
   - Store all images in the `/public/images/` directory
   - Store all videos in the `/public/videos/` directory
   - Use SVG images for logos and icons when possible (allows theme color application)

2. **Config References**:
   - All image and video paths should be defined in the config file
   - Use absolute paths relative to the public directory (e.g., `/images/logo.svg`)
   - For hero sections with video, always provide an image fallback

3. **Video Handling**:
   - Add proper controls and accessibility for video elements
   - Implement playback optimizations (lazy loading, preload="metadata")
   - For autoplay videos, handle autoplay restrictions gracefully with fallbacks

4. **SVG Best Practices**:
   - For theme-sensitive SVGs, use currentColor for fill/stroke to inherit theme colors
   - For complex SVGs, use the img tag with SVG files from the public directory
   - For simple icons that change color with theme, consider inline SVG

Example component with proper image/video handling:

```tsx
import { useConfig } from '~/utils/themeContext';
import { useRef, useEffect } from 'react';

export function HeroSection() {
  const config = useConfig();
  const videoRef = useRef<HTMLVideoElement>(null);
  
  useEffect(() => {
    // Handle autoplay restrictions
    if (videoRef.current) {
      const playPromise = videoRef.current.play();
      if (playPromise !== undefined) {
        playPromise.catch(() => {
          // Video autoplay was prevented, fallback to poster image is shown
        });
      }
    }
  }, []);
  
  return (
    <div className="relative h-screen overflow-hidden">
      {config.heroVideoUrl ? (
        <video
          ref={videoRef}
          poster={config.heroBackgroundImage}
          className="absolute inset-0 w-full h-full object-cover"
          muted
          loop
          playsInline
          preload="metadata"
        >
          <source src={config.heroVideoUrl} type="video/mp4" />
          {/* Fallback to image if video fails */}
        </video>
      ) : (
        <img 
          src={config.heroBackgroundImage} 
          alt={config.heroTitle}
          className="absolute inset-0 w-full h-full object-cover"
        />
      )}
      
      <div className="relative z-10 container mx-auto px-4 h-full flex items-center">
        <div className="text-white max-w-2xl">
          <h1 className="text-4xl md:text-6xl font-bold mb-4">{config.heroTitle}</h1>
          <p className="text-xl mb-8">{config.heroSubtitle}</p>
          <button className="bg-primary hover:bg-primary-600 text-black font-bold py-3 px-8 rounded-sm">
            {config.heroCta}
          </button>
        </div>
      </div>
    </div>
  );
}
```

## Special CSS Classes

The template includes some special CSS classes for common styling needs:

- `shadow-glow`: Adds a glow effect using the primary color
- `animate-pulse`, `animate-fadeIn`, etc.: Animation utilities
- Custom text shadow classes (defined in component-specific styles)

## GraphQL Schema Generation

The project is configured to generate two sets of type definitions:

1. **Used Types Only**:
   - `storefrontapi.generated.d.ts`: Contains types from the Storefront API that are actually used in the application
   - `customer-accountapi.generated.d.ts`: Contains types from the Customer API that are actually used in the application

2. **Full Schema Reference**:
   - `graphql-schema/storefront-schema.generated.ts`: Complete schema types for Storefront API
   - `graphql-schema/customer-schema.generated.ts`: Complete schema types for Customer API

## How to Regenerate Schema Types

To regenerate both used type definitions and full schema references:

```bash
npm run codegen
# or
yarn codegen
```

This command triggers GraphQL code generation based on the configuration in `.graphqlrc.ts`.

## Important Developer Notes

1. When developing new features that interact with Shopify's APIs:
   - For implementation: Use the root-level generated type files (`storefrontapi.generated.d.ts` and `customer-accountapi.generated.d.ts`)
   - For reference/discovery of available API features: Consult the full schema files in `graphql-schema`
   - For latest patterns and examples: Check `./hydrogen-2025-05/` documentation

2. When adding new GraphQL queries:
   - For Storefront API: Add them to the appropriate component or route files
   - For Customer API: Add them to `/app/graphql/customer-account/` directory
   - Then run `npm run codegen` to update the type definitions

3. Don't manually edit the generated type files as they will be overwritten when codegen runs.

4. When working with components:
   - Always use the `useConfig()` hook from `~/utils/themeContext` to access configuration
   - Use Tailwind classes that reference CSS variables for styling
   - Avoid hardcoding any styles or colors that should come from the theme
   - Make components respond to configuration changes

5. When implementing cart functionality:
   - Always pass `selectedVariant` to AddToCartButton components
   - Use flexible type definitions that match actual GraphQL data
   - Use CartForm for all cart operations
   - Test thoroughly using the `/shopify-test` page

## Routes Structure

The project uses a file-based routing system with Remix-style conventions:
- Routes with `($locale)` handle internationalization
- Routes with `._index` represent index pages
- Routes with `.$paramName` handle dynamic parameters
- Routes with `._` denote layout routes

## Key Components
- `PageLayout.tsx`: Main layout component
- `Header.tsx` and `Footer.tsx`: Site-wide navigation components
- `ProductCard.tsx`, `ProductDetail.tsx`: Product display components
- `ProductShowcase.tsx`: Product grid display for featured products
- `CartMain.tsx`, `CartSummary.tsx`: Shopping cart components (FULLY WORKING)
- `CartLineItem.tsx`: Individual cart line items (FULLY WORKING)
- `AddToCartButton.tsx`: Add to cart functionality (FULLY WORKING)
- `Hero.tsx`: Main landing page hero section
- `LimitedEdition.tsx`: Limited edition product section with countdown
- `Aside.tsx`: Slide-in panel for cart, search, and mobile menu

# React Router Import Rule for Hydrogen

## Overview

This Hydrogen project is based on React Router, not Remix. When working with documentation or code examples, you should always use imports from the appropriate React Router packages instead of Remix packages.

## Import Replacements

When you see imports from Remix packages, replace them with their equivalent React Router v7 packages. Here are the common replacements:

| Remix v2 Package | React Router v7 Package |
|------------------|-------------------------|
| `@remix-run/react` | `react-router` |
| `@remix-run/dev` | `@react-router/dev` |
| `@remix-run/architect` | `@react-router/architect` |
| `@remix-run/cloudflare` | `@react-router/cloudflare` |
| `@remix-run/express` | `@react-router/express` |
| `@remix-run/fs-routes` | `@react-router/fs-routes` |
| `@remix-run/node` | `@react-router/node` |
| `@remix-run/route-config` | `@react-router/dev` |
| `@remix-run/routes-option-adapter` | `@react-router/remix-routes-option-adapter` |
| `@remix-run/serve` | `@react-router/serve` |
| `@remix-run/server-runtime` | `react-router` |
| `@remix-run/testing` | `react-router` |

NEVER USE 'react-router-dom' imports!

## Common Import Examples

```js
// INCORRECT (Remix style)
import { useLoaderData, Link, Form, useActionData, useNavigation, useSubmit } from '@remix-run/react';

// CORRECT (React Router style)
import { useLoaderData, Link, Form, useActionData, useNavigation, useSubmit } from 'react-router';
```

## Development Guidelines

1. Always check existing code in the project to understand which specific React Router hooks and components are being used
2. When generating new code or modifying existing code, ensure all routing-related imports come from the correct React Router packages
3. If following documentation or examples based on Remix, adapt the code to use React Router equivalents
4. Reference `./hydrogen-2025-05/` for the latest Hydrogen patterns and examples

When working in this codebase, always follow the React Router patterns that are already established in the existing code.

For more information, consult the official Remix to React Router upgrade guide: https://reactrouter.com/upgrading/remix